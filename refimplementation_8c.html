<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SIGMOD Contest 2011: refimplementation.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">SIGMOD Contest 2011
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">refimplementation.c File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A skeleton implementation of the SIGMOD 2011 programming contest API.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscdb__index.html">scdb_index</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscdb__iterator.html">scdb_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aedda513f77f83c9aaf7dd6292ead3c6f" id="r_aedda513f77f83c9aaf7dd6292ead3c6f"><td class="memItemLeft" align="right" valign="top"><a id="aedda513f77f83c9aaf7dd6292ead3c6f" name="aedda513f77f83c9aaf7dd6292ead3c6f"></a>
DBT *&#160;</td><td class="memItemRight" valign="bottom"><b>initialize_dbt</b> ()</td></tr>
<tr class="separator:aedda513f77f83c9aaf7dd6292ead3c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237f9696668f1afbf7eeaa2dbcd3ed0b" id="r_a237f9696668f1afbf7eeaa2dbcd3ed0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structscdb__index.html">scdb_index</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a237f9696668f1afbf7eeaa2dbcd3ed0b">scdb_open</a> (size_t max_disk_bytes, const char *disk_path)</td></tr>
<tr class="memdesc:a237f9696668f1afbf7eeaa2dbcd3ed0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an existing index, or creates one if it does not exist.  <br /></td></tr>
<tr class="separator:a237f9696668f1afbf7eeaa2dbcd3ed0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38b7f671fbaf4ebb0b9113a85046717" id="r_af38b7f671fbaf4ebb0b9113a85046717"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af38b7f671fbaf4ebb0b9113a85046717">scdb_close</a> (<a class="el" href="structscdb__index.html">scdb_index</a> *index)</td></tr>
<tr class="memdesc:af38b7f671fbaf4ebb0b9113a85046717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes an open index.  <br /></td></tr>
<tr class="separator:af38b7f671fbaf4ebb0b9113a85046717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981fe5043244639bd2cfc485c4790bfc" id="r_a981fe5043244639bd2cfc485c4790bfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50b">scdb_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a981fe5043244639bd2cfc485c4790bfc">scdb_read</a> (<a class="el" href="structscdb__index.html">scdb_index</a> *index, const char *key, size_t key_length, char *value_buffer, size_t *value_buffer_length)</td></tr>
<tr class="memdesc:a981fe5043244639bd2cfc485c4790bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the value corresponding to the specified key (exact match).  <br /></td></tr>
<tr class="separator:a981fe5043244639bd2cfc485c4790bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a6a7dae206b2d55f89344c4240ca3e" id="r_a02a6a7dae206b2d55f89344c4240ca3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50b">scdb_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02a6a7dae206b2d55f89344c4240ca3e">scdb_write</a> (<a class="el" href="structscdb__index.html">scdb_index</a> *index, const char *key, size_t key_length, const char *value, size_t value_length)</td></tr>
<tr class="memdesc:a02a6a7dae206b2d55f89344c4240ca3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the specified key to map to the specified value.  <br /></td></tr>
<tr class="separator:a02a6a7dae206b2d55f89344c4240ca3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6386d3a133944a960f49c47119014738" id="r_a6386d3a133944a960f49c47119014738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50b">scdb_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6386d3a133944a960f49c47119014738">scdb_delete</a> (<a class="el" href="structscdb__index.html">scdb_index</a> *index, const char *key, size_t key_length)</td></tr>
<tr class="memdesc:a6386d3a133944a960f49c47119014738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the specified key and associated value from the index.  <br /></td></tr>
<tr class="separator:a6386d3a133944a960f49c47119014738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde87e8599867ace1c37fc02cb16988d" id="r_acde87e8599867ace1c37fc02cb16988d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50b">scdb_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acde87e8599867ace1c37fc02cb16988d">scdb_cas</a> (<a class="el" href="structscdb__index.html">scdb_index</a> *index, const char *key, size_t key_length, const char *current_value, size_t current_value_length, const char *new_value, size_t new_value_length)</td></tr>
<tr class="memdesc:acde87e8599867ace1c37fc02cb16988d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an atomic compare and swap.  <br /></td></tr>
<tr class="separator:acde87e8599867ace1c37fc02cb16988d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4ae62837785d91a1dea32c26a536da" id="r_a2d4ae62837785d91a1dea32c26a536da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structscdb__iterator.html">scdb_iterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d4ae62837785d91a1dea32c26a536da">scdb_iterate</a> (<a class="el" href="structscdb__index.html">scdb_index</a> *index, const char *key, size_t key_length)</td></tr>
<tr class="memdesc:a2d4ae62837785d91a1dea32c26a536da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an iterator over the index, starting at the smallest key that is greater than or equal to the provided key.  <br /></td></tr>
<tr class="separator:a2d4ae62837785d91a1dea32c26a536da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6598b7af810a2968a9ee11109143dae" id="r_ad6598b7af810a2968a9ee11109143dae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6598b7af810a2968a9ee11109143dae">scdb_iterator_close</a> (<a class="el" href="structscdb__iterator.html">scdb_iterator</a> *iterator)</td></tr>
<tr class="memdesc:ad6598b7af810a2968a9ee11109143dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes an open iterator.  <br /></td></tr>
<tr class="separator:ad6598b7af810a2968a9ee11109143dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c66c67a7dc097f25757dc697b304712" id="r_a8c66c67a7dc097f25757dc697b304712"><td class="memItemLeft" align="right" valign="top"><a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50b">scdb_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c66c67a7dc097f25757dc697b304712">scdb_next</a> (<a class="el" href="structscdb__iterator.html">scdb_iterator</a> *iterator, char *key_buffer, size_t *key_buffer_length, char *value_buffer, size_t *value_buffer_length)</td></tr>
<tr class="memdesc:a8c66c67a7dc097f25757dc697b304712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the current key/value pair from the iterator, then advances the iterator.  <br /></td></tr>
<tr class="separator:a8c66c67a7dc097f25757dc697b304712"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A skeleton implementation of the SIGMOD 2011 programming contest API. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="acde87e8599867ace1c37fc02cb16988d" name="acde87e8599867ace1c37fc02cb16988d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde87e8599867ace1c37fc02cb16988d">&#9670;&#160;</a></span>scdb_cas()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50b">scdb_status</a> scdb_cas </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscdb__index.html">scdb_index</a> *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>key_length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>current_value</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>current_value_length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>new_value</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>new_value_length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs an atomic compare and swap. </p>
<p>If the current value for key matches the provided value, then update the key's value to new_value. The compare and swap occur atomically, each thread can assume that no other thread's updates are applied between the compare and swap operation. This primitive can be used to implement higher-level concurrency control, e.g. locks or validation for optimistic concurrency control.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index to modify. </td></tr>
    <tr><td class="paramname">key</td><td>pointer to the key bytes. </td></tr>
    <tr><td class="paramname">key_length</td><td>length of the key in bytes. Must be &lt;= SCDB_MAX_KEY_LENGTH. </td></tr>
    <tr><td class="paramname">current_value</td><td>pointer to the bytes to be compared with the value stored in the index, cannot be NULL. </td></tr>
    <tr><td class="paramname">current_value_length</td><td>length of current_value in bytes. Must be &lt;= SCDB_MAX_VALUE_LENGTH. </td></tr>
    <tr><td class="paramname">new_value</td><td>pointer to the value to be written if the comparison is successful, cannot be NULL. </td></tr>
    <tr><td class="paramname">new_value_length</td><td>length of the new value in bytes, must be &gt;= 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50ba2205813f38ba1bda93a59963a55a6190">SCDB_OK</a> if the operation is successful, <a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50bace8d43ecf365243936fd16d766983313">SCDB_NOT_FOUND</a> if the key does not exist, <a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50bafae9f43a108edbda8b521596ae8dcc04">SCDB_COMPARE_FAILED</a> if the stored value does not match <code>current_value</code>, <a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50ba08f50232af6f4ff4bfe303f7d5eb9d68">SCDB_ERROR</a> if some other error occurs. </dd></dl>

</div>
</div>
<a id="af38b7f671fbaf4ebb0b9113a85046717" name="af38b7f671fbaf4ebb0b9113a85046717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38b7f671fbaf4ebb0b9113a85046717">&#9670;&#160;</a></span>scdb_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void scdb_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscdb__index.html">scdb_index</a> *</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes an open index. </p>
<p>This should free all resources associated with index. After this is called, the pointer cannot be used by any thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index to be closed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6386d3a133944a960f49c47119014738" name="a6386d3a133944a960f49c47119014738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6386d3a133944a960f49c47119014738">&#9670;&#160;</a></span>scdb_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50b">scdb_status</a> scdb_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscdb__index.html">scdb_index</a> *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>key_length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the specified key and associated value from the index. </p>
<p>After this returns, the delete must be committed and durable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index to modify. </td></tr>
    <tr><td class="paramname">key</td><td>pointer to the key bytes. </td></tr>
    <tr><td class="paramname">key_length</td><td>length of the key in bytes. Must be &lt;= SCDB_MAX_KEY_LENGTH. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50ba2205813f38ba1bda93a59963a55a6190">SCDB_OK</a> if the operation is successful, <a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50bace8d43ecf365243936fd16d766983313">SCDB_NOT_FOUND</a> if the key does not exist, <a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50ba08f50232af6f4ff4bfe303f7d5eb9d68">SCDB_ERROR</a> if some other error occurs. </dd></dl>

</div>
</div>
<a id="a2d4ae62837785d91a1dea32c26a536da" name="a2d4ae62837785d91a1dea32c26a536da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d4ae62837785d91a1dea32c26a536da">&#9670;&#160;</a></span>scdb_iterate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscdb__iterator.html">scdb_iterator</a> * scdb_iterate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscdb__index.html">scdb_index</a> *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>key_length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an iterator over the index, starting at the smallest key that is greater than or equal to the provided key. </p>
<p>The keys are sorted in lexicographical byte order, with bytes treated as 8-bit unsigned integers. For example, the following order is correct: { 0x7f }, { 0x7f, 0x00 }, { 0x80 }. To start at the beginning of the index, pass in a NULL or zero-length key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index to iterate over. </td></tr>
    <tr><td class="paramname">key</td><td>pointer to the key bytes. </td></tr>
    <tr><td class="paramname">key_length</td><td>length of the key in bytes. Must be &lt;= SCDB_MAX_KEY_LENGTH. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to an iterator to be used to read values from the index, or NULL if some error occurred. </dd></dl>

</div>
</div>
<a id="ad6598b7af810a2968a9ee11109143dae" name="ad6598b7af810a2968a9ee11109143dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6598b7af810a2968a9ee11109143dae">&#9670;&#160;</a></span>scdb_iterator_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void scdb_iterator_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscdb__iterator.html">scdb_iterator</a> *</td>          <td class="paramname"><span class="paramname"><em>iterator</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes an open iterator. </p>
<p>The provided iterator pointer cannot be used after calling this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterator</td><td>pointer to the iterator to close. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c66c67a7dc097f25757dc697b304712" name="a8c66c67a7dc097f25757dc697b304712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c66c67a7dc097f25757dc697b304712">&#9670;&#160;</a></span>scdb_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50b">scdb_status</a> scdb_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscdb__iterator.html">scdb_iterator</a> *</td>          <td class="paramname"><span class="paramname"><em>iterator</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>key_buffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>key_buffer_length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>value_buffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>value_buffer_length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the current key/value pair from the iterator, then advances the iterator. </p>
<p>The iterator does not need to be repeatable or isolated with respect to other transactions. The only restriction is that keys must be returned in strictly increasing order, and it must only return committed values.</p>
<p>If there is an error, the iterator is not advanced. If the buffers are too small, the length fields will indicate the length of the data to be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">iterator</td><td>the iterator to read from. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key_buffer</td><td>pointer to memory where the key will be copied. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">key_buffer_length</td><td>pointer to the length of value buffer. This will be set to the length of the key in the index. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">value_buffer</td><td>pointer to memory where the value will be copied. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">value_buffer_length</td><td>pointer to the length of value buffer. This will be set to the length of the value in the index.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd>
<dd>
<a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50ba2205813f38ba1bda93a59963a55a6190">SCDB_OK</a> if the operation is successful, <a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50bace8d43ecf365243936fd16d766983313">SCDB_NOT_FOUND</a> if there are no more keys in the iteration, <a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50ba965c13ab4a82a151ca2ec34dea893c8f">SCDB_KEY_BUFFER_TOO_SMALL</a> if the key is longer than the provided buffer, <a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50ba857fe4f2a393064b05f42668d794ba7c">SCDB_VALUE_BUFFER_TOO_SMALL</a> if the value is longer than the provided buffer, <a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50ba08f50232af6f4ff4bfe303f7d5eb9d68">SCDB_ERROR</a> if some other error occurs. </dd></dl>

</div>
</div>
<a id="a237f9696668f1afbf7eeaa2dbcd3ed0b" name="a237f9696668f1afbf7eeaa2dbcd3ed0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237f9696668f1afbf7eeaa2dbcd3ed0b">&#9670;&#160;</a></span>scdb_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscdb__index.html">scdb_index</a> * scdb_open </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>max_disk_bytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>disk_path</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens an existing index, or creates one if it does not exist. </p>
<p>Any number of files can be used to persist the index, provided that the total amount of space used does not exceed <code>max_disk_bytes</code>. This index must be thread-safe, meaning that it can be passed between multiple threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_disk_bytes</td><td>the maximum amount of disk space available for durability. </td></tr>
    <tr><td class="paramname">disk_path</td><td>the prefix that must be used for storing the non-volatile data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the index that will be passed into all future API calls. </dd></dl>

</div>
</div>
<a id="a981fe5043244639bd2cfc485c4790bfc" name="a981fe5043244639bd2cfc485c4790bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981fe5043244639bd2cfc485c4790bfc">&#9670;&#160;</a></span>scdb_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50b">scdb_status</a> scdb_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscdb__index.html">scdb_index</a> *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>key_length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>value_buffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>value_buffer_length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the value corresponding to the specified key (exact match). </p>
<p>If the provided buffer is too small, this will return SCDB_VALUE_BUFFER_TOO_SMALL and not copy any bytes into <code>value_buffer</code>. However, <code>value_buffer_length</code> is always set to the full length of the value stored in the index. The value returned must reflect the most recent successfully completed (committed) value, even if that update was performed by another thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">index</td><td>the index to modify. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key</td><td>pointer to the key bytes. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">key_length</td><td>length of the key in bytes. Must be &lt;= SCDB_MAX_KEY_LENGTH. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">value_buffer</td><td>pointer to memory where the value will be copied, cannot be NULL. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">value_buffer_length</td><td>pointer to the length of value buffer. This will be set to the length of the value in the index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50ba2205813f38ba1bda93a59963a55a6190">SCDB_OK</a> if the operation is successful, <a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50bace8d43ecf365243936fd16d766983313">SCDB_NOT_FOUND</a> if the key does not exist, <a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50ba857fe4f2a393064b05f42668d794ba7c">SCDB_VALUE_BUFFER_TOO_SMALL</a> if the value is longer than <code>value_buffer</code>, <a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50ba08f50232af6f4ff4bfe303f7d5eb9d68">SCDB_ERROR</a> if some other error occurs. </dd></dl>

</div>
</div>
<a id="a02a6a7dae206b2d55f89344c4240ca3e" name="a02a6a7dae206b2d55f89344c4240ca3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a6a7dae206b2d55f89344c4240ca3e">&#9670;&#160;</a></span>scdb_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50b">scdb_status</a> scdb_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscdb__index.html">scdb_index</a> *</td>          <td class="paramname"><span class="paramname"><em>index</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>key</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>key_length</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>value_buffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>value_length</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the specified key to map to the specified value. </p>
<p>This inserts a new key-value pair or updates the existing key. After this returns, the update must be committed and durable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index to modify. </td></tr>
    <tr><td class="paramname">key</td><td>pointer to the key bytes. </td></tr>
    <tr><td class="paramname">key_length</td><td>length of the key in bytes. Must be &lt;= SCDB_MAX_KEY_LENGTH. </td></tr>
    <tr><td class="paramname">value_buffer</td><td>pointer to the value bytes, cannot be NULL. </td></tr>
    <tr><td class="paramname">value_length</td><td>length of the value in bytes. Must be &lt;= SCDB_MAX_VALUE_LENGTH. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50ba2205813f38ba1bda93a59963a55a6190">SCDB_OK</a> if the operation is successful, <a class="el" href="scdb_8h.html#a4212df977b92d66f2c2481060d0db50ba08f50232af6f4ff4bfe303f7d5eb9d68">SCDB_ERROR</a> if some other error occurs. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat May 25 2024 23:15:04 for SIGMOD Contest 2011 by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
